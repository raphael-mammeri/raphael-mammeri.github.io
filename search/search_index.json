{"config":{"lang":["fr"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Page in progress. There may be typos and the content is subject to change.</p>"},{"location":"#welcome-to-my-personal-page","title":"Welcome to My Personal Page","text":"<p>Welcome to my blog, where I share articles and insights on data science, Python development, mathematics, and lectures on probability theory and machine learning. I'm Raphael Mammeri, a passionate data scientist with a strong background in mathematics, particularly in the field of algebraic geometry. With a Ph.D. in algebraic geometry, I have a deep passion for the beauty and elegance of mathematical concepts and their applications.</p> <p>Through this blog, I aim to combine my expertise in data science and mathematics to provide valuable resources, tutorials, and discussions on various topics. From practical implementations of machine learning algorithms to explorations of complex mathematical theories, my goal is to simplify complex concepts and make them accessible to a wide audience.</p>"},{"location":"#about-me","title":"About Me","text":"<p>With years of experience in both academia and industry, I have worked on numerous projects that have leveraged the power of mathematics and programming. My background in algebraic geometry has provided me with a strong foundation in abstract thinking, problem-solving, and logical reasoning. I believe that mathematics serves as a fundamental tool for understanding and solving real-world problems, and I'm excited to share this passion with you.</p>"},{"location":"#topics-covered","title":"Topics Covered","text":"<p>In this blog, you can expect to find articles covering a wide range of topics, including data science techniques, Python development best practices, and explorations of various mathematical concepts. From practical data analysis and visualization to deep dives into mathematical theories, I strive to present content that is both informative and engaging.</p> <p>Happy reading and coding!</p> <p>Raphael Mammeri, Ph.D.</p>"},{"location":"cv/","title":"Rapha\u00ebl Mammeri","text":""},{"location":"cv/#data-scientist","title":"Data Scientist","text":"<p>Anim\u00e9 par une connaissance approfondie dans la construction de mod\u00e8les d'IA, mon expertise couvre l\u2019ensemble des \u00e9tapes du cycle de vie des mod\u00e8les: de la compr\u00e9hension m\u00e9tiers du besoin au d\u00e9ploiement et du monitoring. J'ai men\u00e9 des projets end-to-end, int\u00e9grant des pipelines CI/CD et des pratiques MLOps pour garantir scalabilit\u00e9, robustesse et automatisation du d\u00e9ploiement en production.</p>"},{"location":"cv/#experience-professionnelle","title":"Exp\u00e9rience Professionnelle","text":""},{"location":"cv/#data-scientis-senior-092021-052024","title":"Data Scientis S\u00e9nior  09/2021  05/2024","text":"BNP Paribas Datalab  Paris Mod\u00e8le de d\u00e9tection de fraude d'octroi de cr\u00e9dits \ud83c\uddeb\ud83c\uddf7  Contexte Responsabilit\u00e9s Environnement technique <p>Le projet visait \u00e0 automatiser la d\u00e9tection de fraudes sur les demandes de cr\u00e9dit en ligne pour le portefeuille France de la marque Cetelem. L'objectif \u00e9tait double : d'une part, acc\u00e9l\u00e9rer le traitement des dossiers sans suspicion de fraude afin de r\u00e9duire le temps de r\u00e9ponse aux clients ; d'autre part, identifier les demandes pr\u00e9sentant un risque \u00e9lev\u00e9 et les signaler aux \u00e9quipes de contr\u00f4le pour une d\u00e9cision finale. Cette solution a consid\u00e9rablement r\u00e9duit le volume de dossiers trait\u00e9s manuellement, optimisant ainsi l'allocation des ressources tout en am\u00e9liorant la rapidit\u00e9 du service client.   </p> <ul> <li>Extraction, transformation et labelisation de donn\u00e9es</li> <li>Optimisation d\u2019un mod\u00e8le XGboost</li> <li>D\u00e9veloppement de l\u2019API d\u2019inf\u00e9rence</li> <li>Cr\u00e9ation de commandes CLI pour l\u2019inf\u00e9rence en batch</li> <li>Packaging du mod\u00e8le pour la mise en production    </li> <li>Mise en place de pipeline CI/CD</li> <li>Monitoring des performances avec le m\u00e9tier</li> </ul> <p><code>Python</code> <code>VSCode</code> <code>XGBoost</code> <code>scikit-learn</code> <code>pandas</code> <code>Hyperopt</code> <code>FastAPI</code> <code>Pydantic</code> <code>Typer</code> <code>Poetry</code> <code>Ruff</code> <code>pre-commit</code> <code>Gitlab CI</code></p> Product Owner \ud83c\uddeb\ud83c\uddf7  Contexte Responsabilit\u00e9s Environnement technique <p>Projet inter-\u00e9quipes (marketing, risk et op\u00e9rations) visant \u00e0 d\u00e9velopper une biblioth\u00e8que Python inner-source interne chez BNP Paribas, avec pour objectif de rationaliser le cycle de vie des projets de machine learning et d'harmoniser les pratiques de d\u00e9veloppement des mod\u00e8les, afin de faciliter leur industrialisation.</p> <ul> <li>Gestion et priorisation de la backlog produit</li> <li>Traduction des besoins m\u00e9tiers en user stories et features pour l'\u00e9quipe de d\u00e9veloppement.</li> <li>Assurer le suivi de l'avancement des d\u00e9veloppements pour garantir le respect des d\u00e9lais, la qualit\u00e9 des livrables.</li> </ul> <p><code>Python</code> <code>VSCode</code> <code>Gitlab CI</code> <code>Docker</code> <code>k8s</code> <code>MLflow</code> <code>Jira</code></p> Score First Unpaid \ud83c\udde7\ud83c\uddea  Contexte Responsabilit\u00e9s Environnement technique <p>Projet ayant pour objectif d\u00e9velopper un mod\u00e8le machine learning pour pr\u00e9dire les premi\u00e8res impay\u00e9s au sein de la filiale belge de BNP Paribas. L'enjeu principal \u00e9tait d'anticiper les d\u00e9fauts de paiement des clients ayant un cr\u00e9dit en cours, en \u00e9valuant la probabilit\u00e9 qu'ils ne paient pas le mois suivant. Gr\u00e2ce \u00e0 ces pr\u00e9dictions, les \u00e9quipes de recouvrement pouvaient prioriser leurs actions et prendre des mesures proactives pour r\u00e9duire les risques de d\u00e9faut, optimisant ainsi l'efficacit\u00e9 de la gestion des impay\u00e9s.</p> <ul> <li>D\u00e9finition du p\u00e9rim\u00e8tre de mod\u00e9lisation en \u00e9change avec le m\u00e9tier</li> <li>Construction de la base de mod\u00e9lisation</li> <li>D\u00e9veloppement d'un mod\u00e8le XGBoost et optimisation</li> <li>Pr\u00e9sentation des r\u00e9sultat aux \u00e9quipes recouvrement</li> <li>Packaging du mod\u00e8le pour la mise en production clean: clean code, tests, pipeline CI/CD, commandes CLI d'inf\u00e9rence en batch</li> <li>Monitoring des performances</li> </ul> <p><code>Python</code> <code>VSCode</code> <code>XGBoost</code> <code>scikit-learn</code> <code>pandas</code> <code>Hyperopt</code> <code>Pydantic</code> <code>Typer</code> <code>Poetry</code> <code>Ruff</code> <code>pre-commit</code> <code>Gitlab CI</code></p> Call Center forecast \ud83c\uddf5\ud83c\uddf9  Contexte Responsabilit\u00e9s Environnement technique <p>TO DO</p> <p>TO DO</p> <p>TO DO</p>"},{"location":"cv/#data-scientist-risk-manager-042018-092021","title":"Data Scientist / Risk Manager  04/2018  09/2021","text":"BNP Paribas Risk  Bordeaux Score de comportement client \ud83c\udde9\ud83c\uddea  Contexte Responsabilit\u00e9s Environnement technique <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <p><code>XGBoost</code> <code>scikit-learn</code></p> Score d'octroi de cr\u00e9dits auto sur le p\u00e9rim\u00e8tre PME \ud83c\uddf9\ud83c\uddf7  Contexte Responsabilit\u00e9s Environnement technique <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <p><code>XGBoost</code> <code>scikit-learn</code></p>"},{"location":"cv/#formation","title":"Formation","text":"<ul> <li>2018 - Master 2 Data Sciences - Universit\u00e9 Paris-Saclay</li> <li>2016 - Doctorat en Math\u00e9matiques Fondamentales - Universit\u00e9 de Lille</li> <li>2012 - Master 2 Math\u00e9matiques et Applications - Universit\u00e9 des Sciences d'Alger</li> <li>2010 - License math\u00e9matiques et informatique - Universit\u00e9 des Sciences d'Alger</li> </ul>"},{"location":"cv/#competences","title":"Comp\u00e9tences","text":""},{"location":"cv/#contact","title":"Contact","text":""},{"location":"articles/cookiecutter/","title":"Cookiecutter","text":"<p>Warning</p> <p>Page in progress. There may be typos and the content is subject to change.</p>"},{"location":"articles/cookiecutter/#how-to-generate-a-python-package-in-5m","title":"How to Generate a Python Package in 5m","text":"<p>Link to lemma</p>"},{"location":"articles/cookiecutter/#intorduction","title":"Intorduction","text":"<p>Creating a new Python package involves setting up a project structure, creating boilerplate code, and configuring various files. This process can  be repetitive and time-consuming, especially when you want to follow best  practices and maintain consistency across multiple projects. This is where  templating tools like  Cookiecutter or Jinja come in as valuable tools.</p> <p>In this tutorial, we will explore the practical application of Cookiecutter to facilitate the creation of a customized template for a Python package. This hands-on tutorial will guide you through the step-by-step process of setting up a Cookiecutter template.</p>"},{"location":"articles/cookiecutter/#install-cookiecutter","title":"Install Cookiecutter","text":"<p>Cookiecutter is a python package so you need to have python installed in  your machine then you can install it with <code>pip</code>: <pre><code>pip install cookiecutter\n</code></pre></p>"},{"location":"articles/cookiecutter/#usage","title":"Usage","text":"<p>Basically a Cookiecutter template project is a diretory containing a sub-directory that will be copied when generating a project from it. The way it works is that iside this subdirectory (in file of directory names  and within files) you can use \"variables\" that will be replaced by Cookiecutter.</p> <pre><code>mkdir PythonProjectGenerator\ncd PythonProjectGenerator\nmkdir {{cookiecutter.project_name}}\n</code></pre>"},{"location":"blog/","title":"This is the blog index","text":""},{"location":"blog/2023-07-17-how-to-generate-a-python-package-in-5m/","title":"How to Generate a Python Package in 5m","text":"<p>Creating a new Python package involves setting up a project structure, creating boilerplate code, and configuring various files. This process can be repetitive and time-consuming, especially when you want to follow best  practices and maintain consistency across multiple projects. This is where  templating tools like  Cookiecutter or Jinja come in as valuable tools.</p> <p>In this tutorial, we will explore the practical application of Cookiecutter to facilitate the creation of a customized template for a Python package. This hands-on tutorial will guide you through the step-by-step process of setting up a Cookiecutter template.</p> <p>Lemma 1.1  (1), this  could be</p> <ol> <li>If \\(f = \\sum_{i=1}^{m} \\beta_i \\mathbf{1}_{A_i}\\) is another      reperesentation of \\(f\\) then:      $$     \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) = \\sum_{i=1}^{m} \\beta_i \\mu(B_i)     $$     Moreover the map \\(f \\mapsto \\int{f\\\\ d\\mu}\\) is positive linear and      monotone increasing.</li> </ol>"},{"location":"blog/2023-07-17-how-to-generate-a-python-package-in-5m/#install-cookiecutter","title":"Install Cookiecutter","text":"<p>Cookiecutter is a python package so you need to have python installed in  your machine then you can install it with <code>pip</code>: <pre><code>pip install cookiecutter\n</code></pre></p>"},{"location":"blog/2023-07-17-how-to-generate-a-python-package-in-5m/#usage","title":"Usage","text":"<p>Basically a Cookiecutter template project is a diretory containing a sub-directory that will be copied when generating a project from it. The way it works is that iside this subdirectory (in file of directory names  and within files) you can use \"variables\" that will be replaced by Cookiecutter.</p> <pre><code>mkdir PythonProjectGenerator\ncd PythonProjectGenerator\nmkdir {{cookiecutter.project_name}}\n</code></pre>"},{"location":"notes/","title":"Index","text":""},{"location":"notes/#notes","title":"Notes","text":"<p>Cauchy</p>"},{"location":"notes/dl/backpropagation/","title":"Back Propagation","text":""},{"location":"notes/dl/backpropagation/#gradient","title":"Gradient","text":"<p>Let \\(f: \\mathbb{R}^n \\to \\mathbb{R}\\) differentiable.  $$ \\nabla f = \\left[ \\frac{\\partial f}{\\partial x_1}, \\cdots, \\frac{\\partial f}{\\partial x_n} \\right]^{T}  $$ If \\(f\\) is with values in \\(\\mathbb{R}^m\\): $$ \\nabla f = \\left( \\frac{\\partial f_j}{\\partial x_i} \\right)_{i=1, \\cdots, n, j=1, \\cdots m} $$ For \\(\\mathbf{x} \\in \\mathbb{R}^n\\) : \\(\\nabla_{\\mathbf{x}}f\\) is an \\(n\\times m\\) matrice having gradients \\(\\nabla_{\\mathbf{x}} f_j\\) as columns.</p>"},{"location":"notes/dl/backpropagation/#gradient-of-composition","title":"Gradient of composition","text":"<p>Let \\(h : \\mathbb{R}^n \\xrightarrow[\\text{}]{g} \\mathbb{R}^m  \\xrightarrow[\\text{}]{f} \\mathbb{R}\\) and \\(\\mathbf{y} = g(\\mathbf{x})\\). We have: $$ \\nabla_{\\mathbf{x}}h $$</p>"},{"location":"notes/probability/dev/","title":"Dev","text":""},{"location":"notes/probability/dev/#hello","title":"Hello","text":"<p>@tag(semi)</p> <p>Semi</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\). The class \\(\\mathcal{A}\\) is called  a semiring if :</p> <ul> <li>\\(\\emptyset \\in \\mathcal{A}\\),</li> <li>for any \\(A, B \\in \\mathcal{A}\\) then \\(B \\setminus A\\) is a finite union of mutually disjoint sets in \\(\\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cap\\)-closed i.e. closed under finite intersections.</li> </ul>"},{"location":"notes/probability/dev/#voila","title":"voila","text":"<p>Definition @tag(semi-new)</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\). The class \\(\\mathcal{A}\\) is called  a semi-ring if :</p> <ul> <li>\\(\\emptyset \\in \\mathcal{A}\\),</li> <li>for any \\(A, B \\in \\mathcal{A}\\) then \\(B \\setminus A\\) is a finite union of mutually disjoint sets in \\(\\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cap\\)-closed i.e. closed under finite intersections.</li> </ul> <p>and this is a line of text</p>"},{"location":"notes/probability/examples/","title":"Examples","text":""},{"location":"notes/probability/examples/#eulers-prime-number-formula","title":"Euler\u2019s prime number formula","text":"<p>@tag(Euler\u2019s formula)</p> <p>Euler\u2019s prime number formula</p> <p>This is a warning to say that the content of this page is purely for demonstration purposes</p>"},{"location":"notes/probability/funtions/","title":"functions","text":"<p>A {\\it subcategory} of a category \\(\\mathcal{B}\\) is a category \\(\\mathcal{A}\\) whose objects and arrows form subsets of the objects and arrows of \\(\\mathcal{B}\\) and such that source, target and composition in \\(\\mathcal{A}\\) agree with those of \\(\\mathcal{B}\\) and such that the identity morphism of an object of \\(\\mathcal{A}\\) matches the one in \\(\\mathcal{B}\\). We say \\(\\mathcal{A}\\) is a {\\it full subcategory} of \\(\\mathcal{B}\\) if \\(\\Mor_\\mathcal{A}(x, y) = \\Mor_\\mathcal{B}(x, y)\\) for all \\(x, y \\in \\Ob(\\mathcal{A})\\). We say \\(\\mathcal{A}\\) is a {\\it strictly full} subcategory of \\(\\mathcal{B}\\) if it is a full subcategory and given \\(x \\in \\Ob(\\mathcal{A})\\) any object of \\(\\mathcal{B}\\) which is isomorphic to \\(x\\) is also in \\(\\mathcal{A}\\).</p> <p>Phasellus posuere in sem ut cursus (1)</p> <p>Lorem ipsum dolor sit amet, (2) consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <ol> <li> I'm an annotation!</li> <li> I'm an annotation as well!</li> </ol> <p>integral of positive functions</p>"},{"location":"notes/probability/integration/","title":"Integration","text":"<p>Warning</p> <p>Page in progress. There may be typos and the content is subject to change.</p>"},{"location":"notes/probability/integration/#basic-definitions-and-results-of-the-integral","title":"Basic Definitions and Results of the Integral","text":"<p>This is a reference to Semi-Rings definition</p> <p>In this section \\((\\Omega, \\mathcal{A}, \\mu)\\) will be a measure space. Let \\(\\mathbb{E}\\) be the set of simple functions on \\(\\Omega\\) and  \\(\\mathbb{E}^+\\) the set of positive simple functions (values in \\([0, \\infty]\\)).</p> <p>!!! definition  Integral of positive simple functions id=1     We define the integral of a positive simple function     \\(f = \\sum_{i=1}^n \\alpha_i\\mathbf{1}_{A_i}\\)     by:     $$     \\int{f\\ d\\mu} := \\sum_{i=1}^{n} \\alpha_i \\mu(A_i)     $$ For this definition to be correct we need to make sure it does not depend on the representation of \\(f\\):</p> <p>Lemma</p> <p>If \\(f = \\sum_{i=1}^{m} \\beta_i \\mathbf{1}_{A_i}\\) is another  reperesentation of \\(f\\) then:  $$ \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) = \\sum_{i=1}^{m} \\beta_i \\mu(B_i) $$ Moreover the map \\(f \\mapsto \\int{f\\\\ d\\mu}\\) is positive linear and  monotone increasing.</p> <p>Starting from positive simple functions we now extend the definition of  the integral to measurable functions.</p> <p>Definition</p> <p>Let \\(f: \\Omega \\to [0, \\infty]\\) be measurable. We define the  integral of \\(f\\) by: $$ \\int{f\\ d\\mu} := \\underset{g \\in \\mathbb{E}^+,\\ g\\leq f}{\\text{sup}} \\int g\\ d\\mu $$ Now let \\(f\\) with values in \\(\\overline{\\mathbb{R}}.\\) The function \\(f\\) is called \\(\\mu\\)-integrable if  \\(\\int |f| \\\\ d\\mu &lt; \\infty\\).</p> <p>We note \\(\\mathcal{L}^1(\\Omega, \\mathcal{A}, \\mu)\\), or simply \\(\\mathcal{L}^1(\\mu)\\), the set of \\(\\mu\\)-integrable functions.</p> <p>For \\(f \\in \\mathcal{L}^1(\\mu)\\) we define: $$ \\int f \\ d\\mu := \\int f^+ \\ d\\mu - \\int f^- \\ d\\mu  $$ Finally, if \\(A \\in \\mathcal{A}\\) we define: $$ \\int_A f \\ d\\mu := \\int (f \\cdot \\mathbf{1}_A) \\ d\\mu $$</p> <p>Lemma</p> <p>For \\(i \\geq 1\\), let \\(f_i : \\Omega \\to [0, \\infty]\\) be measurable. If \\(f_i \\uparrow f\\) to some measurable function \\(f : \\Omega \\to [0, \\infty]\\) then \\(\\int{f_i} d\\mu \\uparrow \\int{f d\\mu}\\)</p>"},{"location":"notes/probability/integration/#the-rest","title":"The rest","text":"<p>In this section \\((\\Omega, \\mathcal{A}, \\mu)\\) will be a measure space. Let \\(\\mathbb{E}\\) be the set of simple functions on @tag(omega) \\(\\Omega\\) and  \\(\\mathbb{E}^+\\) the set of positive simple functions (values in \\([0, \\infty]\\)).</p> <p>Definition</p> <p>We define the integral of a positive simple function \\(f = \\sum_{i=1}^n \\alpha_i\\mathbf{1}_{A_i}\\) by: $$ \\int{f\\ d\\mu} := \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) $$</p> <p>Definition</p> <p>We define the integral of a positive simple function \\(f = \\sum_{i=1}^n \\alpha_i\\mathbf{1}_{A_i}\\) by: $$ \\int{f\\ d\\mu} := \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) $$</p> <p>@tag(integral of positive functions)</p> <p>Definition</p> <p>We define the integral of a positive simple function \\(f = \\sum_{i=1}^n \\alpha_i\\mathbf{1}_{A_i}\\) by: $$ \\int{f\\ d\\mu} := \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) $$</p> <p>For this definition to be correct we need to make sure it does not depend on the representation of \\(f\\):</p> <p>Lemma</p> <p>If \\(f = \\sum_{i=1}^{m} \\beta_i \\mathbf{1}_{A_i}\\) is another  reperesentation of \\(f\\) then:  $$ \\sum_{i=1}^{n} \\alpha_i \\mu(A_i) = \\sum_{i=1}^{m} \\beta_i \\mu(B_i) $$</p> <p>Destination anchors</p> <p>Lemma</p> <p>Let \\(f, g \\in \\mathbb{E}^+\\) and \\(\\alpha &gt; 0\\). We have:</p> <ul> <li>\\(\\int \\alpha f = \\alpha \\int f\\)</li> <li>\\(\\int f + g = \\int f + \\int g\\)</li> <li>if \\(f \\leq g\\) then \\(\\int f \\leq \\int g\\)</li> </ul> <p>This is a paragraph I want to link to.</p> <p>Lemma</p> <p>For \\(i \\geq 1\\), let \\(f_i : \\Omega \\to [0, \\infty]\\) be measurable. If \\(f_i \\uparrow f\\) to some measurable function \\(f : \\Omega \\to [0, \\infty]\\) then \\(\\int{f_i} d\\mu \\uparrow \\int{f d\\mu}\\)</p> <p>!!! Lemma \"Cauchy-Schwarz Inequatlity\" @tag(Cauchy)     Let \\(X\\), \\(Y\\) in \\(\\mathcal{L}^2(\\mathbf{P})\\), then :     $$     \\left(\\mathbf{Cov}[X,Y] \\right)^2 \\leq \\mathbf{Var}[X] \\mathbf{Var}[Y]     $$</p> <p>Let \\(X\\), \\(Y\\) in \\(\\mathcal{L}^2(\\mathbf{P})\\), then : $$ \\left(\\mathbf{Cov}[X,Y] \\right)^2 \\leq \\mathbf{Var}[X] \\mathbf{Var}[Y] $$</p>"},{"location":"notes/probability/introduction/","title":"Introduction","text":"<p>This course is designed for readers with a good knowledge of the mathematical subjects taught in the first one or two years of university and who have some experience of mathematical reasoning.</p>"},{"location":"notes/probability/introduction/#the-objectif-these-lectures","title":"The objectif these lectures","text":""},{"location":"notes/probability/introduction/#organization","title":"Organization","text":"<p>Although we may reference to some probabilitic interpretations the 4* first sections introduce measure theory and integration in a general way. Starting from section : probabilistics we dive into the probabilistic framework.</p>"},{"location":"notes/probability/introduction/#notations","title":"Notations","text":"<ul> <li>i.e.</li> <li>R bar</li> <li>\\(\\mathcal{P}(\\Omega)\\)</li> <li>cf</li> <li>countable sets</li> <li>liminf &amp; limsup</li> <li>indicator functions</li> <li>up and down sets unions</li> </ul> <p>something here</p> <p>sigma</p> <p>algebra</p> <p>Some text here the rest of the line. Another text here and a third line here</p> <p>Some text here  the rest of the line. Another text here and a third line here</p>"},{"location":"notes/probability/measure_theory/","title":"Measure theory","text":""},{"location":"notes/probability/measure_theory/#introduction","title":"Introduction","text":"<p>Measure theory is a branch of mathematics that provides a rigorous framework for understanding and quantifying the concept of size or measure of sets. It deals with the study of measures, which are functions that assign a non-negative real number to subsets of a given set. In probability theory,  measure theory introduces key concepts such as  probability spaces, sample spaces and events. The numerical values that are  assigned to events will capture the likelihood or uncertainty of outcomes. These concepts establish a solid foundation for studying probabilistic  models and their properties.</p> <p>In this section we will start by defining some classes of sets like algebras, \\(\\sigma\\)-algebras...etc. These classes will define the subsets on which measures will be defined (and extended). They are important to ensure that if we can measure some sets of a space, then the sets resulting from unions, intersections, or other operations that will be specified in the next subsections, will also be measurable. This will result in the definition of measurable spaces.</p> <p>After that we will give definitions and properties of set functions and define measures spaces and probability spaces then state the measure extension theorem which is crucial for the construction of many measures espacially in the case of real numbers.</p> <p>Finally, using the results of the previous subsections we introduce the Lebesgue-Borel measure in the case of real numbers \\(\\mathbb{R}\\) and more generally \\(\\mathbb{R}^n\\).</p> <p>Before we dive into the technical definitions and results let's consider the example of real numbers which is interesting as it illustrates well the process of measures construction. Suppose we want to measure subsets of \\(\\mathbb{R}.\\) To start we can consider the \"simple\" subsets of intervals \\(\\mathcal{A} = \\{ I \\subseteq \\mathbb{R}\\ |\\ I \\text{ is an interval in }\\mathbb{R} \\}\\) and \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) the set function defined for an interval \\(I\\) with sides \\(a\\) and \\(b\\) (either open or closed on the sides) by: $$ \\mu(I) = b - a $$ This gives a natural and intuitive sens of a measure on such sets. However can we extend this definition to a broader set of subsets of \\(\\mathbb{R}\\) ? We can easily extend it to finite unions of such intervals. For example for two disjoint intervals \\(I\\) and \\(J\\) in \\(\\mathcal{A}\\) we define: $$ \\mu(I \\cup J) = \\mu(I) + \\mu(J)  $$ and so on for the union of more than two intervals. We can eaily check that this definition does not depend on the representation of the finite unions as a disjoint union of intervals. Before continuing the discussion on the extension of such a set function we can start to see some properties that measures will have:</p> <ul> <li>the measure of the empty set (\\(]a, a[\\) for some \\(a \\in \\mathbb{R}\\)) is equal to \\(a-a = 0\\),</li> <li>if \\(A\\) and \\(B\\) are finite unions of intervals such that \\(A \\subseteq B\\) then \\(\\mu(A) \\leq \\mu(B)\\) and</li> <li>the measure of disjoint unions of sets is the sum of the measures of theses sets.</li> </ul> <p>Back to the extension of the set function \\(\\mu\\), the questions we could have are:</p> <ul> <li>can \\(\\mu\\) be extended to all subsets of \\(\\mathbb{R}\\) ?</li> <li>If not can we extend it more than to the finite unions of intervals ?</li> <li>What about defining similar measures for \\(\\mathbb{R}^n\\) where \\(n &gt; 1\\) ?</li> </ul> <p>The precise answers to these questions will be given in subsections Measure Extension Theorem and Lebesgue-Borel Measure.</p>"},{"location":"notes/probability/measure_theory/#classes-of-sets","title":"Classes of sets","text":"<p>The most important class of sets is the class of \\(\\sigma\\)-algebras. It is the class on which measures and probability measures are defined. However, as we will see, measures on \\(\\sigma\\)-algebras are usually defined on a smaller class then extended to the generated \\(\\sigma\\)-algebra. One of these smaller classes is the class of semi-rings.</p> <p>We will note \\(\\Omega\\) a non-empty set.</p> <p>@tag(semi-rings)</p> <p>Semi-rings</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\). The class \\(\\mathcal{A}\\) is called  a semiring if :</p> <ul> <li>\\(\\emptyset \\in \\mathcal{A}\\),</li> <li>for any \\(A, B \\in \\mathcal{A}\\) then \\(B \\setminus A\\) is a finite union of mutually disjoint sets in \\(\\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cap\\)-closed i.e. closed under finite intersections.</li> </ul> <p>Definition</p> <p>An algebra (resp. \\(\\sigma\\)-algebra) if :</p> <ul> <li>\\(\\Omega \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is closed under complements,</li> <li>Closed under finite (resp. countable) unions, and we write \\(\\mathcal{A}\\) is \\(\\cup\\)-closed (resp. \\(\\sigma\\)-\\(\\cup\\)-closed).</li> </ul> <p>@tag(sigma) The \\(\\sigma\\)-algebras are the classes of sets that will be considered as events in probability theory, and more generally the classes on which measures are defined.</p> <p>Lemma</p> <p>@tag(algebra definition) The class \\(\\mathcal{A}\\) is an algebra if and only if:</p> <ul> <li>\\(\\Omega \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\setminus\\)-closed i.e. for any \\(A, B \\in \\mathcal{A}\\) then \\(A \\setminus B \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cup\\)-closed.</li> </ul> <p>If \\(\\mathcal{A}\\) is an algebra (resp. \\(\\sigma\\)-algebra) then \\(\\mathcal{A}\\) is \\(\\cap\\)-closed (resp. \\(\\sigma\\)-\\(\\cap\\)-closed).</p> <p>Proof</p> <p>We leave the proof of the first part to the reader. The second part is a consequence of de Morgan's rule: \\((\\cup A_i)^c = \\cap A_i^c\\).</p> <p>It is easy to show that for any arbitrary non-empty index set \\(I\\) and \\((\\mathcal{A}_i)_{i \\in I}\\) a family of algebras (resp. \\(\\sigma\\)-algeras) the intersection \\(\\cap_I\\mathcal{A}_i\\) is also an algebra (resp. \\(\\sigma\\)-algebra).</p> <p>Let \\(\\mathcal{E} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(I\\) the set of \\(\\sigma\\)-algebras of \\(\\Omega\\) containing \\(\\mathcal{E}.\\) The \\(\\sigma\\)-algebra $$ \\sigma(\\mathcal{E}):= \\cap_{\\mathcal{A} \\in I}\\mathcal{A} $$ is called the \\(\\sigma\\)-algebra generated by \\(\\mathcal{E}\\) and \\(\\mathcal{E}\\) is called a generator of \\(\\sigma(\\mathcal{E}).\\)</p> <p>Note that in the definition above the index set \\(I\\) is never empty since it contains the \\(\\sigma\\)-algebra \\(\\mathcal{P}(\\Omega).\\) It is also clear from the definiton above that if \\(\\mathcal{E}\\) is a \\(\\sigma\\)-algebra then \\(\\mathcal{E}=\\sigma(\\mathcal{E})\\) and if \\(\\mathcal{E'} \\subseteq \\mathcal{E}\\) then \\(\\sigma(\\mathcal{E'}) \\subseteq \\sigma(\\mathcal{E})\\).</p> <p>Definition</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(A \\subseteq \\Omega\\) non-empty. The class $$ \\mathcal{A}\\vert_A := \\{A \\cap B \\ ; B \\in \\mathcal{A} \\} $$ is called the trace of \\(\\mathcal{A}\\) on \\(A\\) or the restriction of \\(\\mathcal{A}\\) to \\(A\\).</p> <p>It can easily be shown that if \\(\\mathcal{A}\\) is an algebra (resp. \\(\\sigma\\)-algebra) on \\(\\Omega\\) then \\(\\mathcal{A}\\vert_A\\) is an algebra (resp. \\(\\sigma\\)-algebra) on \\(A\\) for any non-empty \\(A \\subseteq \\Omega\\).</p>"},{"location":"notes/probability/measure_theory/#measure-spaces","title":"Measure Spaces","text":"<p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\),   \\(\\mu: \\mathcal{A} \\to [0, \\infty]\\) a set function,   \\(I\\) an index set and \\((A_i)_{i \\in I}\\) such that \\(A_i \\in \\mathcal{A}\\) for any \\(i \\in I\\).</p> <p>Definition</p> <p>We say that \\(\\mu\\) is :</p> <ul> <li>monotone if \\(\\mu(A) \\leq \\mu(B)\\) for any \\(A \\subseteq B\\)  in \\(\\mathcal{A}\\),</li> <li>additive if \\(\\mu(\\cup_{i \\in I}A_i) = \\sum_{i \\in I}\\mu(A_i)\\) for \\(I\\) finite and \\((A_i)_{i \\in I}\\) mutually disjoint,</li> <li>\\(\\sigma\\)-additive if \\(\\mu(\\cup_{i \\in I}A_i) = \\sum_{i \\in I}\\mu(A_i)\\) for \\(I\\) countable and \\((A_i)_{i \\in I}\\) mutually disjoint,</li> <li>subadditive if for any \\(A\\subseteq \\cup_{i \\in I}A_i\\) and \\(I\\) finite we have \\(\\mu(A) \\leq \\sum_{i \\in I}\\mu(A_i)\\),</li> <li>\\(\\sigma\\)-subadditive if for any \\(A\\subseteq \\cup_{i \\in I}A_i\\) and \\(I\\) countable we have \\(\\mu(A) \\leq \\sum_{i \\in I}\\mu(A_i)\\),</li> <li>a content if \\(\\mathcal{A}\\) is a semiring, \\(\\mu(\\emptyset)=0\\) and \\(\\mu\\) is additive.</li> </ul> <p>Definition</p> <p>A set function \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) is called a measure on \\((\\Omega, \\mathcal{A})\\) if \\(\\mathcal{A}\\) is a \\(\\sigma\\)-algebra, \\(\\mu(\\emptyset)=0\\) and \\(\\mu\\) is \\(\\sigma\\)-additive.</p> <p>Let \\(\\mu\\) be a content on a semiring \\(\\mathcal{A}\\). </p> <p>Definition</p> <p>We say that \\(\\mu\\) is finite if \\(\\mu(\\Omega) &lt; \\infty\\) and  \\(\\sigma\\)-finite if there exists a family \\((\\Omega_n)_{n \\in \\mathbb{N}}\\) in \\(\\mathcal{A}\\) such that \\(\\Omega = \\cup_{n \\in \\mathbb{N}}\\Omega_n\\) and \\(\\mu(\\Omega_n) &lt; \\infty\\) for all \\(n \\in \\mathbb{N}\\).</p> <p>Let \\(\\Omega\\) be a non-empty set and \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) a set function.</p> <p>Definition</p> <ul> <li>We say that the pair \\((\\Omega, \\mathcal{A})\\) is a measurable space if \\(\\mathcal{A}\\) is a \\(\\sigma\\)-algebra and \\(\\mu\\) a measure on \\(\\mathcal{A}\\).</li> <li>If \\((\\Omega, \\mathcal{A})\\) is a measurable space subsets of \\(\\Omega\\) in \\(\\mathcal{A}\\) are called measurable sets.</li> <li>A measurable space \\((\\Omega, \\mathcal{A})\\) is called discrete if \\(\\Omega\\) is at most countable and \\(\\mathcal{A}=\\mathcal{P}(\\Omega)\\).</li> <li>The set of finite (resp. \\(\\sigma\\)-finite) measures on a measurable space \\((\\Omega, \\mathcal{A})\\) is denoted \\(\\mathcal{M}_f(\\Omega, \\mathcal{A})\\) (resp. \\(\\mathcal{M}_{\\sigma}(\\Omega, \\mathcal{A})\\)).</li> </ul> <p>Let \\(\\mu\\) be a content on a \\(\\sigma\\)-algebra \\(\\mathcal{A}\\)</p> <p>Lemma</p> <p>The following three properties are equivalent </p> <ul> <li>\\(\\mu\\) is a measure (it is a \\(\\sigma\\)-additive)</li> <li>\\(\\mu\\) is \\(\\sigma\\)-subadditive</li> <li>\\(\\mu\\) is lower semicontinuous</li> </ul> <p>@tag(Measure Extension Theorem)</p>"},{"location":"notes/probability/measure_theory/#measure-extension-theorem","title":"Measure Extension Theorem","text":"<p>!!! danger \"Measure Extension Theorem\" @tag(measure_extension_theorem)     Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) be a semiring and  \\(\\mu: \\mathcal{A} \\to [0, \\infty]\\) additive, \\(\\sigma\\)-subadditive, \\(\\sigma\\)-finite and \\(\\mu(\\emptyset)=0\\).     There exists a unique \\(\\sigma\\)-finite measure \\(\\tilde{\\mu }\\) on \\(\\sigma(\\mathcal{A})\\) such that for any \\(A \\in \\mathcal{A}\\):     $$     \\tilde{\\mu }(A) = \\mu(A)     $$</p> Sketch of the proof <p>The proof of this theorem is beyond the scope of these lectures however we give a sketch here of the construction of the extended measure \\(\\tilde{\\mu }\\). From \\(\\mu\\) a set function \\(\\mu^*\\) on \\(\\mathcal{P}(\\Omega)\\) is defined as follows: for any \\(A \\subseteq \\Omega\\):</p> \\[ \\mu^*(A):= \\inf_{(A_i)_{i \\in I} \\in \\mathcal{U}(A)} \\sum_{i \\in I} \\mu(A_i) \\] <p>where \\(\\mathcal{U}(A)\\) is the set of countable coverings \\((A_i)_{i \\in I}\\) of \\(A\\) (i.e. \\(A \\subseteq \\cup_{i \\in I}A_i\\)) with \\(A_i \\in \\mathcal{A}\\) for all \\(i \\in I\\). The set function \\(\\mu^*\\) is an outer measure that defines a measure on the \\(\\sigma\\)-algebra \\(\\mathcal{M}(\\mu^*)\\) of \\(\\mu^*\\)-measurable sets. Moreover for any \\(A \\in \\mathcal{A}\\), \\(\\mu(A) = \\mu^*(A)\\), \\(\\mathcal{A} \\subseteq \\mathcal{M}(\\mu^*)\\) hence \\(\\sigma(\\mathcal{A}) \\subseteq \\mathcal{M}(\\mu^*)\\)  and \\(\\mu^*\\) is the unique measure that extends \\(\\mu\\) to \\(\\sigma(\\mathcal{A})\\).</p> <p>@tag(lebesgue-Borel)</p>"},{"location":"notes/probability/measure_theory/#lebesgue-borel-measure","title":"Lebesgue-Borel Measure","text":"<ul> <li>Borel sigma algebra of a topological space</li> <li>The example of \\(\\mathbb{R}^n\\)</li> <li>List of generators of the Borel sigma algebra on \\(\\mathbb{R}^n\\)</li> <li>Make the remark that the classes of generator cited are countable and that this is a very crucial property</li> </ul>"},{"location":"notes/probability/measure_theory_copy/","title":"Measure theory copy","text":""},{"location":"notes/probability/measure_theory_copy/#introduction","title":"Introduction","text":"<p>Measure theory is a branch of mathematics that provides a rigorous framework for understanding and quantifying the concept of size or measure of sets. It deals with the study of measures, which are functions that assign a non-negative real number to subsets of a given set. In probability theory,  measure theory introduces key concepts such as  probability spaces, sample spaces and events. The numerical values that are  assigned to events will capture the likelihood or uncertainty of outcomes. These concepts establish a solid foundation for studying probabilistic  models and their properties.</p> <p>In this section we will start by defining some classes of sets like algebras, \\(\\sigma\\)-algebras...etc. These classes will define the subsets on which measures will be defined (and extended). They are important to ensure that if we can measure some sets of a space, then the sets resulting from unions, intersections, or other operations that will be specified in the next subsections, will also be measurable. This will result in the definition of measurable spaces.</p> <p>After that we will give definitions and properties of set functions and define measures spaces and probability spaces then state the measure extension theorem which is crucial for the construction of many measures espacially in the case of real numbers.</p> <p>Finally, using the results of the previous subsections we introduce the Lebesgue-Borel measure in the case of real numbers \\(\\mathbb{R}\\) and more generally \\(\\mathbb{R}^n\\).</p> <p>Before we dive into the technical definitions and results let's consider the example of real numbers which is interesting as it illustrates well the process of measures construction. Suppose we want to measure subsets of \\(\\mathbb{R}.\\) To start we can consider the \"simple\" subsets of intervals \\(\\mathcal{A} = \\{ I \\subseteq \\mathbb{R}\\ |\\ I \\text{ is an interval in }\\mathbb{R} \\}\\) and \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) the set function defined for an interval \\(I\\) with sides \\(a\\) and \\(b\\) (either open or closed on the sides) by: $$ \\mu(I) = b - a $$ This gives a natural and intuitive sens of a measure on such sets. However can we extend this definition to a broader set of subsets of \\(\\mathbb{R}\\) ? We can easily extend it to finite unions of such intervals. For example for two disjoint intervals \\(I\\) and \\(J\\) in \\(\\mathcal{A}\\) we define: $$ \\mu(I \\cup J) = \\mu(I) + \\mu(J)  $$ and so on for the union of more than two intervals. We can eaily check that this definition does not depend on the representation of the finite unions as a disjoint union of intervals. Before continuing the discussion on the extension of such a set function we can start to see some properties that measures will have:</p> <ul> <li>the measure of the empty set (\\(]a, a[\\) for some \\(a \\in \\mathbb{R}\\)) is equal to \\(a-a = 0\\),</li> <li>if \\(A\\) and \\(B\\) are finite unions of intervals such that \\(A \\subseteq B\\) then \\(\\mu(A) \\leq \\mu(B)\\) and</li> <li>the measure of disjoint unions of sets is the sum of the measures of theses sets.</li> </ul> <p>Back to the extension of the set function \\(\\mu\\), the questions we could have are:</p> <ul> <li>can \\(\\mu\\) be extended to all subsets of \\(\\mathbb{R}\\) ?</li> <li>If not can we extend it more than to the finite unions of intervals ?</li> <li>What about defining similar measures for \\(\\mathbb{R}^n\\) where \\(n &gt; 1\\) ?</li> </ul> <p>The precise answers to these questions will be given in subsections Measure Extension Theorem and Lebesgue-Borel Measure.</p>"},{"location":"notes/probability/measure_theory_copy/#classes-of-sets","title":"Classes of sets","text":"<p>The most important class of sets is the class of \\(\\sigma\\)-algebras. It is the class on which measures and probability measures are defined. However, as we will see, measures on \\(\\sigma\\)-algebras are usually defined on a smaller class then extended to the generated \\(\\sigma\\)-algebra. One of these smaller classes is the class of semi-rings.</p> <p>We will note \\(\\Omega\\) a non-empty set.</p> <p>@tag(semi-rings)</p> <p>Semi-rings</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\). The class \\(\\mathcal{A}\\) is called  a semiring if :</p> <ul> <li>\\(\\emptyset \\in \\mathcal{A}\\),</li> <li>for any \\(A, B \\in \\mathcal{A}\\) then \\(B \\setminus A\\) is a finite union of mutually disjoint sets in \\(\\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cap\\)-closed i.e. closed under finite intersections.</li> </ul> <p>Definition</p> <p>An algebra (resp. \\(\\sigma\\)-algebra) if :</p> <ul> <li>\\(\\Omega \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is closed under complements,</li> <li>Closed under finite (resp. countable) unions, and we write \\(\\mathcal{A}\\) is \\(\\cup\\)-closed (resp. \\(\\sigma\\)-\\(\\cup\\)-closed).</li> </ul> <p>@tag(sigma) The \\(\\sigma\\)-algebras are the classes of sets that will be considered as events in probability theory, and more generally the classes on which measures are defined.</p> <p>Lemma</p> <p>@tag(algebra definition) The class \\(\\mathcal{A}\\) is an algebra if and only if:</p> <ul> <li>\\(\\Omega \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\setminus\\)-closed i.e. for any \\(A, B \\in \\mathcal{A}\\) then \\(A \\setminus B \\in \\mathcal{A}\\),</li> <li>\\(\\mathcal{A}\\) is \\(\\cup\\)-closed.</li> </ul> <p>If \\(\\mathcal{A}\\) is an algebra (resp. \\(\\sigma\\)-algebra) then \\(\\mathcal{A}\\) is \\(\\cap\\)-closed (resp. \\(\\sigma\\)-\\(\\cap\\)-closed).</p> <p>Proof</p> <p>We leave the proof of the first part to the reader. The second part is a consequence of de Morgan's rule: \\((\\cup A_i)^c = \\cap A_i^c\\).</p> <p>It is easy to show that for any arbitrary non-empty index set \\(I\\) and \\((\\mathcal{A}_i)_{i \\in I}\\) a family of algebras (resp. \\(\\sigma\\)-algeras) the intersection \\(\\cap_I\\mathcal{A}_i\\) is also an algebra (resp. \\(\\sigma\\)-algebra).</p> <p>Let \\(\\mathcal{E} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(I\\) the set of \\(\\sigma\\)-algebras of \\(\\Omega\\) containing \\(\\mathcal{E}.\\) The \\(\\sigma\\)-algebra $$ \\sigma(\\mathcal{E}):= \\cap_{\\mathcal{A} \\in I}\\mathcal{A} $$ is called the \\(\\sigma\\)-algebra generated by \\(\\mathcal{E}\\) and \\(\\mathcal{E}\\) is called a generator of \\(\\sigma(\\mathcal{E}).\\)</p> <p>Note that in the definition above the index set \\(I\\) is never empty since it contains the \\(\\sigma\\)-algebra \\(\\mathcal{P}(\\Omega).\\) It is also clear from the definiton above that if \\(\\mathcal{E}\\) is a \\(\\sigma\\)-algebra then \\(\\mathcal{E}=\\sigma(\\mathcal{E})\\) and if \\(\\mathcal{E'} \\subseteq \\mathcal{E}\\) then \\(\\sigma(\\mathcal{E'}) \\subseteq \\sigma(\\mathcal{E})\\).</p> <p>Definition</p> <p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(A \\subseteq \\Omega\\) non-empty. The class $$ \\mathcal{A}\\vert_A := \\{A \\cap B \\ ; B \\in \\mathcal{A} \\} $$ is called the trace of \\(\\mathcal{A}\\) on \\(A\\) or the restriction of \\(\\mathcal{A}\\) to \\(A\\).</p> <p>It can easily be shown that if \\(\\mathcal{A}\\) is an algebra (resp. \\(\\sigma\\)-algebra) on \\(\\Omega\\) then \\(\\mathcal{A}\\vert_A\\) is an algebra (resp. \\(\\sigma\\)-algebra) on \\(A\\) for any non-empty \\(A \\subseteq \\Omega\\).</p>"},{"location":"notes/probability/measure_theory_copy/#measure-spaces","title":"Measure Spaces","text":"<p>Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\),   \\(\\mu: \\mathcal{A} \\to [0, \\infty]\\) a set function,   \\(I\\) an index set and \\((A_i)_{i \\in I}\\) such that \\(A_i \\in \\mathcal{A}\\) for any \\(i \\in I\\).</p> <p>Definition</p> <p>We say that \\(\\mu\\) is :</p> <ul> <li>monotone if \\(\\mu(A) \\leq \\mu(B)\\) for any \\(A \\subseteq B\\)  in \\(\\mathcal{A}\\),</li> <li>additive if \\(\\mu(\\cup_{i \\in I}A_i) = \\sum_{i \\in I}\\mu(A_i)\\) for \\(I\\) finite and \\((A_i)_{i \\in I}\\) mutually disjoint,</li> <li>\\(\\sigma\\)-additive if \\(\\mu(\\cup_{i \\in I}A_i) = \\sum_{i \\in I}\\mu(A_i)\\) for \\(I\\) countable and \\((A_i)_{i \\in I}\\) mutually disjoint,</li> <li>subadditive if for any \\(A\\subseteq \\cup_{i \\in I}A_i\\) and \\(I\\) finite we have \\(\\mu(A) \\leq \\sum_{i \\in I}\\mu(A_i)\\),</li> <li>\\(\\sigma\\)-subadditive if for any \\(A\\subseteq \\cup_{i \\in I}A_i\\) and \\(I\\) countable we have \\(\\mu(A) \\leq \\sum_{i \\in I}\\mu(A_i)\\),</li> <li>a content if \\(\\mathcal{A}\\) is a semiring, \\(\\mu(\\emptyset)=0\\) and \\(\\mu\\) is additive.</li> </ul> <p>Definition</p> <p>A set function \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) is called a measure on \\((\\Omega, \\mathcal{A})\\) if \\(\\mathcal{A}\\) is a \\(\\sigma\\)-algebra, \\(\\mu(\\emptyset)=0\\) and \\(\\mu\\) is \\(\\sigma\\)-additive.</p> <p>Let \\(\\mu\\) be a content on a semiring \\(\\mathcal{A}\\). </p> <p>Definition</p> <p>We say that \\(\\mu\\) is finite if \\(\\mu(\\Omega) &lt; \\infty\\) and  \\(\\sigma\\)-finite if there exists a family \\((\\Omega_n)_{n \\in \\mathbb{N}}\\) in \\(\\mathcal{A}\\) such that \\(\\Omega = \\cup_{n \\in \\mathbb{N}}\\Omega_n\\) and \\(\\mu(\\Omega_n) &lt; \\infty\\) for all \\(n \\in \\mathbb{N}\\).</p> <p>Let \\(\\Omega\\) be a non-empty set and \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) and \\(\\mu : \\mathcal{A} \\to [0, \\infty]\\) a set function.</p> <p>Definition</p> <ul> <li>We say that the pair \\((\\Omega, \\mathcal{A})\\) is a measurable space if \\(\\mathcal{A}\\) is a \\(\\sigma\\)-algebra and \\(\\mu\\) a measure on \\(\\mathcal{A}\\).</li> <li>If \\((\\Omega, \\mathcal{A})\\) is a measurable space subsets of \\(\\Omega\\) in \\(\\mathcal{A}\\) are called measurable sets.</li> <li>A measurable space \\((\\Omega, \\mathcal{A})\\) is called discrete if \\(\\Omega\\) is at most countable and \\(\\mathcal{A}=\\mathcal{P}(\\Omega)\\).</li> <li>The set of finite (resp. \\(\\sigma\\)-finite) measures on a measurable space \\((\\Omega, \\mathcal{A})\\) is denoted \\(\\mathcal{M}_f(\\Omega, \\mathcal{A})\\) (resp. \\(\\mathcal{M}_{\\sigma}(\\Omega, \\mathcal{A})\\)).</li> </ul> <p>Let \\(\\mu\\) be a content on a \\(\\sigma\\)-algebra \\(\\mathcal{A}\\)</p> <p>Lemma</p> <p>The following three properties are equivalent </p> <ul> <li>\\(\\mu\\) is a measure (it is a \\(\\sigma\\)-additive)</li> <li>\\(\\mu\\) is \\(\\sigma\\)-subadditive</li> <li>\\(\\mu\\) is lower semicontinuous</li> </ul> <p>@tag(Measure Extension Theorem)</p>"},{"location":"notes/probability/measure_theory_copy/#measure-extension-theorem","title":"Measure Extension Theorem","text":"<p>!!! danger \"Measure Extension Theorem\" @tag(measure_extension_theorem)     Let \\(\\mathcal{A} \\subseteq \\mathcal{P}(\\Omega)\\) be a semiring and  \\(\\mu: \\mathcal{A} \\to [0, \\infty]\\) additive, \\(\\sigma\\)-subadditive, \\(\\sigma\\)-finite and \\(\\mu(\\emptyset)=0\\).     There exists a unique \\(\\sigma\\)-finite measure \\(\\tilde{\\mu }\\) on \\(\\sigma(\\mathcal{A})\\) such that for any \\(A \\in \\mathcal{A}\\):     $$     \\tilde{\\mu }(A) = \\mu(A)     $$</p> Sketch of the proof <p>The proof of this theorem is beyond the scope of these lectures however we give a sketch here of the construction of the extended measure \\(\\tilde{\\mu }\\). From \\(\\mu\\) a set function \\(\\mu^*\\) on \\(\\mathcal{P}(\\Omega)\\) is defined as follows: for any \\(A \\subseteq \\Omega\\):</p> \\[ \\mu^*(A):= \\inf_{(A_i)_{i \\in I} \\in \\mathcal{U}(A)} \\sum_{i \\in I} \\mu(A_i) \\] <p>where \\(\\mathcal{U}(A)\\) is the set of countable coverings \\((A_i)_{i \\in I}\\) of \\(A\\) (i.e. \\(A \\subseteq \\cup_{i \\in I}A_i\\)) with \\(A_i \\in \\mathcal{A}\\) for all \\(i \\in I\\). The set function \\(\\mu^*\\) is an outer measure that defines a measure on the \\(\\sigma\\)-algebra \\(\\mathcal{M}(\\mu^*)\\) of \\(\\mu^*\\)-measurable sets. Moreover for any \\(A \\in \\mathcal{A}\\), \\(\\mu(A) = \\mu^*(A)\\), \\(\\mathcal{A} \\subseteq \\mathcal{M}(\\mu^*)\\) hence \\(\\sigma(\\mathcal{A}) \\subseteq \\mathcal{M}(\\mu^*)\\)  and \\(\\mu^*\\) is the unique measure that extends \\(\\mu\\) to \\(\\sigma(\\mathcal{A})\\).</p> <p>@tag(lebesgue-Borel)</p>"},{"location":"notes/probability/measure_theory_copy/#lebesgue-borel-measure","title":"Lebesgue-Borel Measure","text":"<ul> <li>Borel sigma algebra of a topological space</li> <li>The example of \\(\\mathbb{R}^n\\)</li> <li>List of generators of the Borel sigma algebra on \\(\\mathbb{R}^n\\)</li> <li>Make the remark that the classes of generator cited are countable and that this is a very crucial property</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>empty<ul> <li>hello</li> <li>plugin</li> <li>utils</li> <li>utils_bis</li> </ul> </li> </ul>"},{"location":"reference/hello/","title":"Hello","text":""},{"location":"reference/hello/#empty.hello.hello","title":"<code>hello(name)</code>","text":"<p>Just a greeting example.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <pre><code>Name to greet.\n</code></pre> required <p>Returns:</p> Type Description <code>        str</code> <p>greeting message.</p>"},{"location":"reference/plugin/","title":"Plugin","text":""},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils_bis/","title":"Utils bis","text":""},{"location":"reference/utils_bis/#empty.utils_bis.load_navigation","title":"<code>load_navigation()</code>","text":"<p>Load Mkdocs navigation object</p>"},{"location":"reference/utils_bis/#empty.utils_bis.path_meta","title":"<code>path_meta(path)</code>","text":"<p>Extract content and meta infos from markdown</p> <p>Return tuple of content and dictionary of meta information.</p>"},{"location":"reference/utils_bis/#empty.utils_bis.refactor_adm","title":"<code>refactor_adm(line)</code>","text":"<p>Transform admonition first line</p> <p>Expected syntax : !!! adm_name adm_title id=id_txt No extra quotes needed, id part must be last.</p>"},{"location":"reference/utils_bis/#empty.utils_bis.update_content","title":"<code>update_content(page, ref_dict=None)</code>","text":"<p>Replace references to id with  href links</p>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/machine-learning/","title":"Machine Learning","text":""}]}